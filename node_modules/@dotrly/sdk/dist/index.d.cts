import { ClassValue } from 'clsx';
export { Accordion, AccordionContent, AccordionItem, AccordionTrigger, Alert, AlertAction, AlertDescription, AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogMedia, AlertDialogOverlay, AlertDialogPortal, AlertDialogTitle, AlertDialogTrigger, AlertTitle, AspectRatio, Avatar, AvatarBadge, AvatarFallback, AvatarGroup, AvatarGroupCount, AvatarImage, Badge, Breadcrumb, BreadcrumbEllipsis, BreadcrumbItem, BreadcrumbLink, BreadcrumbList, BreadcrumbPage, BreadcrumbSeparator, Button, ButtonGroup, ButtonGroupSeparator, ButtonGroupText, Calendar, CalendarDayButton, Card, CardAction, CardContent, CardDescription, CardFooter, CardHeader, CardTitle, Carousel, CarouselApi, CarouselContent, CarouselItem, CarouselNext, CarouselPrevious, ChartConfig, ChartContainer, ChartLegend, ChartLegendContent, ChartStyle, ChartTooltip, ChartTooltipContent, Checkbox, Collapsible, CollapsibleContent, CollapsibleTrigger, Combobox, ComboboxChip, ComboboxChips, ComboboxChipsInput, ComboboxCollection, ComboboxContent, ComboboxEmpty, ComboboxGroup, ComboboxInput, ComboboxItem, ComboboxLabel, ComboboxList, ComboboxSeparator, ComboboxTrigger, ComboboxValue, Command, CommandDialog, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList, CommandSeparator, CommandShortcut, ContextMenu, ContextMenuCheckboxItem, ContextMenuContent, ContextMenuGroup, ContextMenuItem, ContextMenuLabel, ContextMenuPortal, ContextMenuRadioGroup, ContextMenuRadioItem, ContextMenuSeparator, ContextMenuShortcut, ContextMenuSub, ContextMenuSubContent, ContextMenuSubTrigger, ContextMenuTrigger, Dialog, DialogClose, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogOverlay, DialogPortal, DialogTitle, DialogTrigger, Drawer, DrawerClose, DrawerContent, DrawerDescription, DrawerFooter, DrawerHeader, DrawerOverlay, DrawerPortal, DrawerTitle, DrawerTrigger, DropdownMenu, DropdownMenuCheckboxItem, DropdownMenuContent, DropdownMenuGroup, DropdownMenuItem, DropdownMenuLabel, DropdownMenuPortal, DropdownMenuRadioGroup, DropdownMenuRadioItem, DropdownMenuSeparator, DropdownMenuShortcut, DropdownMenuSub, DropdownMenuSubContent, DropdownMenuSubTrigger, DropdownMenuTrigger, Empty, EmptyContent, EmptyDescription, EmptyHeader, EmptyMedia, EmptyTitle, Field, FieldContent, FieldDescription, FieldError, FieldGroup, FieldLabel, FieldLegend, FieldSeparator, FieldSet, FieldTitle, HoverCard, HoverCardContent, HoverCardTrigger, Input, InputGroup, InputGroupAddon, InputGroupButton, InputGroupInput, InputGroupText, InputGroupTextarea, InputOTP, InputOTPGroup, InputOTPSeparator, InputOTPSlot, Item, ItemActions, ItemContent, ItemDescription, ItemFooter, ItemGroup, ItemHeader, ItemMedia, ItemSeparator, ItemTitle, Kbd, KbdGroup, Label, Menubar, MenubarCheckboxItem, MenubarContent, MenubarGroup, MenubarItem, MenubarLabel, MenubarMenu, MenubarPortal, MenubarRadioGroup, MenubarRadioItem, MenubarSeparator, MenubarShortcut, MenubarSub, MenubarSubContent, MenubarSubTrigger, MenubarTrigger, NavigationMenu, NavigationMenuContent, NavigationMenuIndicator, NavigationMenuItem, NavigationMenuLink, NavigationMenuList, NavigationMenuTrigger, NavigationMenuViewport, Pagination, PaginationContent, PaginationEllipsis, PaginationItem, PaginationLink, PaginationNext, PaginationPrevious, Popover, PopoverAnchor, PopoverContent, PopoverDescription, PopoverHeader, PopoverTitle, PopoverTrigger, Progress, RadioGroup, RadioGroupItem, ResizableHandle, ResizablePanel, ResizablePanelGroup, ScrollArea, ScrollBar, Select, SelectContent, SelectGroup, SelectItem, SelectLabel, SelectScrollDownButton, SelectScrollUpButton, SelectSeparator, SelectTrigger, SelectValue, Separator, Sheet, SheetClose, SheetContent, SheetDescription, SheetFooter, SheetHeader, SheetTitle, SheetTrigger, Sidebar, SidebarContent, SidebarFooter, SidebarGroup, SidebarGroupAction, SidebarGroupContent, SidebarGroupLabel, SidebarHeader, SidebarInput, SidebarInset, SidebarMenu, SidebarMenuAction, SidebarMenuBadge, SidebarMenuButton, SidebarMenuItem, SidebarMenuSkeleton, SidebarMenuSub, SidebarMenuSubButton, SidebarMenuSubItem, SidebarProvider, SidebarRail, SidebarSeparator, SidebarTrigger, Skeleton, Slider, Spinner, Switch, Table, TableBody, TableCaption, TableCell, TableFooter, TableHead, TableHeader, TableRow, Tabs, TabsContent, TabsList, TabsTrigger, Textarea, Toaster, Toggle, ToggleGroup, ToggleGroupItem, Tooltip, TooltipContent, TooltipProvider, TooltipTrigger, badgeVariants, buttonGroupVariants, buttonVariants, navigationMenuTriggerStyle, tabsListVariants, toggleVariants, useCarousel, useComboboxAnchor, useSidebar } from './components/ui/index.cjs';
import * as react_jsx_runtime from 'react/jsx-runtime';
import * as React from 'react';
import { ReactNode, CSSProperties } from 'react';
import 'radix-ui';
import 'class-variance-authority/types';
import 'class-variance-authority';
import 'react-day-picker';
import 'embla-carousel-react';
import 'recharts';
import '@base-ui/react';
import 'cmdk';
import 'vaul';
import 'input-otp';
import 'sonner';

declare function cn(...inputs: ClassValue[]): string;

type KeyboardBehavior = 'padding' | 'height' | 'position';
interface KeyboardAvoidingViewProps {
    children: ReactNode;
    behavior?: KeyboardBehavior;
    keyboardVerticalOffset?: number;
    style?: CSSProperties;
    className?: string;
}
/**
 * KeyboardAvoidingView - Automatically adjusts content when keyboard opens
 *
 * @param behavior - How to adjust: 'padding' | 'height' | 'position'
 * @param keyboardVerticalOffset - Additional offset to add
 */
declare function KeyboardAvoidingView({ children, behavior, keyboardVerticalOffset, style, className }: KeyboardAvoidingViewProps): react_jsx_runtime.JSX.Element;
type SafeAreaEdge = 'top' | 'bottom' | 'left' | 'right';
interface SafeAreaViewProps {
    children: ReactNode;
    edges?: SafeAreaEdge[];
    style?: CSSProperties;
    className?: string;
}
/**
 * SafeAreaView - Container that respects safe area insets
 *
 * @param edges - Which edges to apply safe area to (default: all)
 */
declare function SafeAreaView({ children, edges, style, className }: SafeAreaViewProps): react_jsx_runtime.JSX.Element;
interface PlatformHeaderProps {
    title: string;
    showBack?: boolean;
    onBack?: () => void;
    className?: string;
    rightElement?: ReactNode;
}
declare function PlatformHeader({ title, showBack, onBack, className, rightElement }: PlatformHeaderProps): react_jsx_runtime.JSX.Element;

type TimerMode = 'focus' | 'shortBreak' | 'longBreak';
type StoryState = 'egg' | 'cracked' | 'chick' | 'alien' | 'ghost';
declare function useFocusTimer(): {
    seconds: number;
    initialTime: number;
    isActive: boolean;
    mode: TimerMode;
    task: string;
    storyState: StoryState;
    soundEnabled: boolean;
    setSeconds: React.Dispatch<React.SetStateAction<number>>;
    setInitialTime: React.Dispatch<React.SetStateAction<number>>;
    setIsActive: React.Dispatch<React.SetStateAction<boolean>>;
    setMode: React.Dispatch<React.SetStateAction<TimerMode>>;
    setTask: React.Dispatch<React.SetStateAction<string>>;
    setStoryState: React.Dispatch<React.SetStateAction<StoryState>>;
    setSoundEnabled: React.Dispatch<React.SetStateAction<boolean>>;
    toggleTimer: () => void;
    giveUp: () => void;
    switchMode: (newMode: TimerMode) => void;
    resetTimer: () => void;
    setCustomTime: (mins: number) => void;
};

declare function useIsMobile(): boolean;

interface KeyboardState {
    isOpen: boolean;
    height: number;
}
/**
 * useKeyboard - Track virtual keyboard state on mobile devices
 *
 * Uses visualViewport API to detect keyboard height and provides
 * a safe area offset for positioning UI elements above the keyboard.
 *
 * @returns {KeyboardState} - { isOpen: boolean, height: number }
 */
declare function useKeyboard(): KeyboardState;
/**
 * useRelayClose - Get the close function for closing the current app
 *
 * Works with both iframe and blob URL contexts.
 *
 * @returns {() => void} - Function to close the current app
 */
declare function useRelayClose(): () => void;

interface SafeAreaInsets {
    top: number;
    bottom: number;
    left: number;
    right: number;
}
interface SafeAreaProviderProps {
    children: ReactNode;
}
/**
 * SafeAreaProvider - Provides safe area insets to child components
 *
 * Automatically detects safe areas from:
 * 1. CSS env() values (iOS Safari)
 * 2. Parent Shell postMessage (when running in Relay Shell)
 */
declare function SafeAreaProvider({ children }: SafeAreaProviderProps): react_jsx_runtime.JSX.Element;
/**
 * useSafeArea - Get safe area insets
 *
 * @returns SafeAreaInsets with top, bottom, left, right values in pixels
 */
declare function useSafeArea(): SafeAreaInsets;
type ColorScheme = 'light' | 'dark';
/**
 * useColorScheme - Get current system color scheme
 *
 * @returns 'light' | 'dark'
 */
declare function useColorScheme(): ColorScheme;
/**
 * useStatusBar - Control the status bar appearance
 *
 * @param color - Hex color for the status bar
 */
declare function useStatusBar(color: string): void;
/**
 * useBackHandler - Handle back navigation
 *
 * @param handler - Return true to prevent default back behavior
 */
declare function useBackHandler(handler: () => boolean): void;
type AppState = 'active' | 'background' | 'inactive';
/**
 * useAppState - Track app foreground/background state
 *
 * @returns Current app state
 */
declare function useAppState(): AppState;

interface NotificationOptions {
    body?: string;
    icon?: string;
    image?: string;
    badge?: string;
    tag?: string;
    data?: any;
    vibrate?: number[];
    timestamp?: number;
    renotify?: boolean;
    silent?: boolean;
    requireInteraction?: boolean;
    actions?: NotificationAction[];
}
interface NotificationAction {
    action: string;
    title: string;
    icon?: string;
}
interface UseNotificationsReturn {
    permission: NotificationPermission;
    requestPermission: () => Promise<NotificationPermission>;
    sendNotification: (title: string, options?: NotificationOptions) => void;
    scheduleNotification: (title: string, delayMs: number, options?: NotificationOptions) => void;
    clearBadge: () => Promise<void>;
    setBadge: (count: number) => Promise<void>;
}
declare function useNotifications(): UseNotificationsReturn;

interface ClipboardItem {
    type: 'text' | 'image' | 'html';
    content: string | Blob;
    timestamp: number;
}
interface UseClipboardReturn {
    clipboardContent: string | null;
    history: ClipboardItem[];
    copyText: (text: string) => Promise<void>;
    copyImage: (blob: Blob) => Promise<void>;
    readText: () => Promise<string>;
    readContent: () => Promise<ClipboardItems>;
    clearHistory: () => void;
}
declare function useClipboard(): UseClipboardReturn;

interface LocationState {
    loading: boolean;
    accuracy: number | null;
    altitude: number | null;
    altitudeAccuracy: number | null;
    heading: number | null;
    latitude: number | null;
    longitude: number | null;
    speed: number | null;
    timestamp: number | null;
    error: GeolocationPositionError | null;
}
interface Geofence {
    id: string;
    latitude: number;
    longitude: number;
    radius: number;
}
interface UseGeolocationReturn extends LocationState {
    getLocation: () => void;
    watchLocation: (options?: PositionOptions) => void;
    clearWatch: () => void;
    checkGeofence: (fence: Geofence) => boolean;
    distanceTo: (lat: number, lng: number) => number;
}
declare function useGeolocation(options?: PositionOptions): UseGeolocationReturn;

interface CameraState {
    stream: MediaStream | null;
    error: Error | null;
    permission: PermissionState | 'unknown';
    isRecording: boolean;
    devices: MediaDeviceInfo[];
}
interface CameraOptions {
    video?: boolean | MediaTrackConstraints;
    audio?: boolean | MediaTrackConstraints;
}
interface UseCameraReturn extends CameraState {
    startCamera: (options?: CameraOptions) => Promise<MediaStream | undefined>;
    stopCamera: () => void;
    takePhoto: () => Promise<string | undefined>;
    startRecording: () => void;
    stopRecording: () => Promise<Blob | undefined>;
    startScreenShare: (options?: DisplayMediaStreamOptions) => Promise<MediaStream | undefined>;
    switchDevice: (deviceId: string, kind: 'video' | 'audio') => Promise<void>;
    getDevices: () => Promise<MediaDeviceInfo[]>;
}
declare function useCamera(): UseCameraReturn;

interface OllamaModel {
    name: string;
    modified_at: string;
    size: number;
    digest: string;
    details: {
        parent_model: string;
        format: string;
        family: string;
        families: string[];
        parameter_size: string;
        quantization_level: string;
    };
}
interface OllamaResponse {
    model: string;
    created_at: string;
    response?: string;
    message?: {
        role: string;
        content: string;
    };
    done: boolean;
    context?: number[];
    total_duration?: number;
    load_duration?: number;
    prompt_eval_count?: number;
    prompt_eval_duration?: number;
    eval_count?: number;
    eval_duration?: number;
}
interface UseOllamaReturn {
    available: boolean;
    loading: boolean;
    models: OllamaModel[];
    refreshModels: () => Promise<void>;
    generate: (model: string, prompt: string, options?: any) => Promise<OllamaResponse>;
    chat: (model: string, messages: {
        role: string;
        content: string;
    }[], options?: any) => Promise<OllamaResponse>;
}
declare function useOllama(): UseOllamaReturn;

export { type AppState, type CameraOptions, type CameraState, type ClipboardItem, type ColorScheme, type Geofence, KeyboardAvoidingView, type LocationState, type NotificationAction, type NotificationOptions, type OllamaModel, type OllamaResponse, PlatformHeader, type SafeAreaInsets, SafeAreaProvider, SafeAreaView, type StoryState, type TimerMode, type UseCameraReturn, type UseClipboardReturn, type UseGeolocationReturn, type UseNotificationsReturn, type UseOllamaReturn, cn, useAppState, useBackHandler, useCamera, useClipboard, useColorScheme, useFocusTimer, useGeolocation, useIsMobile, useKeyboard, useNotifications, useOllama, useRelayClose, useSafeArea, useStatusBar };
