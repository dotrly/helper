{"version":3,"sources":["/Users/jas/Desktop/relay/sdk/dist/index.cjs","../src/hooks/use-keyboard.ts","../src/hooks/use-platform.tsx","../src/hooks/use-notifications.ts"],"names":["useKeyboard","state","setState","useState","maxHeight","useRef","useEffect","updateKeyboardState","viewport","currentHeight","keyboardHeight","isOpen","handleOrientationChange","handleFocusIn","e","target","handleFocusOut","useRelayClose","useCallback","defaultInsets","SafeAreaContext","createContext","SafeAreaProvider","children","insets","setInsets","computeInsets","style","getEnv","name","value"],"mappings":"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","file":"/Users/jas/Desktop/relay/sdk/dist/index.cjs","sourcesContent":[null,"import { useState, useEffect, useCallback, useRef } from 'react';\n\ninterface KeyboardState {\n    isOpen: boolean;\n    height: number;\n}\n\n/**\n * useKeyboard - Track virtual keyboard state on mobile devices\n * \n * Uses visualViewport API to detect keyboard height and provides\n * a safe area offset for positioning UI elements above the keyboard.\n * \n * @returns {KeyboardState} - { isOpen: boolean, height: number }\n */\nexport function useKeyboard(): KeyboardState {\n    const [state, setState] = useState<KeyboardState>({\n        isOpen: false,\n        height: 0\n    });\n\n    // Track maximum height to detect resizing keyboards\n    const maxHeight = useRef(typeof window !== 'undefined' ? window.innerHeight : 0);\n\n    useEffect(() => {\n        // Check if we're on a mobile device\n        const isMobile = /iPad|iPhone|iPod|Android/.test(navigator.userAgent);\n        if (!isMobile) return;\n\n        const updateKeyboardState = () => {\n            if (!window.visualViewport) return;\n\n            const viewport = window.visualViewport;\n            const currentHeight = window.innerHeight;\n\n            // Update baseline if window grows (keyboard closed or orientation change)\n            if (currentHeight > maxHeight.current) {\n                maxHeight.current = currentHeight;\n            }\n\n            // 1. Check for overlay keyboard (viewport shrinks, window stays same)\n            // This happens on iOS by default\n            let keyboardHeight = currentHeight - viewport.height;\n\n            // 2. Check for resizing keyboard (window shrinks)\n            // This happens on Android and iOS with interactive-widget=resizes-content\n            if (keyboardHeight <= 0) {\n                keyboardHeight = maxHeight.current - currentHeight;\n            }\n\n            // Consider keyboard open if height is more than 100px\n            const isOpen = keyboardHeight > 100;\n\n            setState({\n                isOpen,\n                height: isOpen ? keyboardHeight : 0\n            });\n        };\n\n        // Listen to visualViewport changes\n        if (window.visualViewport) {\n            window.visualViewport.addEventListener('resize', updateKeyboardState);\n            window.visualViewport.addEventListener('scroll', updateKeyboardState);\n        }\n\n        // Handle orientation changes to reset baseline\n        const handleOrientationChange = () => {\n            // Small delay to let resize happen\n            setTimeout(() => {\n                maxHeight.current = window.innerHeight;\n                updateKeyboardState();\n            }, 100);\n        };\n\n        window.addEventListener('orientationchange', handleOrientationChange);\n        if (window.screen?.orientation) {\n            window.screen.orientation.addEventListener('change', handleOrientationChange);\n        }\n\n        // Also listen for focus/blur on inputs as fallback\n        const handleFocusIn = (e: FocusEvent) => {\n            const target = e.target as HTMLElement;\n            if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {\n                // Small delay to let keyboard animate\n                setTimeout(updateKeyboardState, 100);\n            }\n        };\n\n        const handleFocusOut = () => {\n            // Small delay to let keyboard animate closed\n            setTimeout(() => {\n                setState({ isOpen: false, height: 0 });\n            }, 100);\n        };\n\n        document.addEventListener('focusin', handleFocusIn);\n        document.addEventListener('focusout', handleFocusOut);\n\n        // Initial check\n        updateKeyboardState();\n\n        return () => {\n            window.visualViewport?.removeEventListener('resize', updateKeyboardState);\n            window.visualViewport?.removeEventListener('scroll', updateKeyboardState);\n            document.removeEventListener('focusin', handleFocusIn);\n            document.removeEventListener('focusout', handleFocusOut);\n        };\n    }, []);\n\n    return state;\n}\n\n/**\n * useRelayClose - Get the close function for closing the current app\n * \n * Works with both iframe and blob URL contexts.\n * \n * @returns {() => void} - Function to close the current app\n */\nexport function useRelayClose(): () => void {\n    const close = useCallback(() => {\n        // 1. PostMessage to self (works in Relay Shell with direct rendering)\n        window.postMessage('relay:close', '*');\n\n        // 2. PostMessage to parent (works in iframe)\n        if (window.parent !== window) {\n            window.parent.postMessage('relay:close', '*');\n        }\n\n        // 3. PostMessage with opener (works if opened as popup)\n        if (window.opener) {\n            window.opener.postMessage('relay:close', '*');\n        }\n    }, []);\n\n    return close;\n}\n","import { useState, useEffect, useCallback, createContext, useContext, ReactNode } from 'react';\n\n// ============================================\n// SAFE AREA TYPES & CONTEXT\n// ============================================\n\nexport interface SafeAreaInsets {\n    top: number;\n    bottom: number;\n    left: number;\n    right: number;\n}\n\nconst defaultInsets: SafeAreaInsets = {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n};\n\nconst SafeAreaContext = createContext<SafeAreaInsets>(defaultInsets);\n\n// ============================================\n// SAFE AREA PROVIDER\n// ============================================\n\ninterface SafeAreaProviderProps {\n    children: ReactNode;\n}\n\n/**\n * SafeAreaProvider - Provides safe area insets to child components\n * \n * Automatically detects safe areas from:\n * 1. CSS env() values (iOS Safari)\n * 2. Parent Shell postMessage (when running in Relay Shell)\n */\nexport function SafeAreaProvider({ children }: SafeAreaProviderProps) {\n    const [insets, setInsets] = useState<SafeAreaInsets>(defaultInsets);\n\n    useEffect(() => {\n        // Method 1: Read from CSS env() values\n        const computeInsets = () => {\n            const style = getComputedStyle(document.documentElement);\n            const getEnv = (name: string) => {\n                const value = style.getPropertyValue(`--safe-area-inset-${name}`);\n                return parseInt(value) || 0;\n            };\n\n            // Try to get from CSS custom properties first\n            let top = getEnv('top');\n            let bottom = getEnv('bottom');\n            let left = getEnv('left');\n            let right = getEnv('right');\n\n            // If CSS props not set, try to read from env() directly\n            if (top === 0 && bottom === 0) {\n                // Create a temp element to measure env() values\n                const temp = document.createElement('div');\n                temp.style.cssText = `\n          position: fixed;\n          top: env(safe-area-inset-top, 0px);\n          bottom: env(safe-area-inset-bottom, 0px);\n          left: env(safe-area-inset-left, 0px);\n          right: env(safe-area-inset-right, 0px);\n          pointer-events: none;\n          visibility: hidden;\n        `;\n                document.body.appendChild(temp);\n                const rect = temp.getBoundingClientRect();\n                top = rect.top;\n                bottom = window.innerHeight - rect.bottom;\n                left = rect.left;\n                right = window.innerWidth - rect.right;\n                document.body.removeChild(temp);\n            }\n\n            setInsets({ top, bottom, left, right });\n        };\n\n        // Method 2: Listen for Shell messages\n        const handleMessage = (event: MessageEvent) => {\n            if (event.data?.type === 'relay:safearea') {\n                setInsets(event.data.insets);\n            }\n        };\n\n        computeInsets();\n        window.addEventListener('message', handleMessage);\n        window.addEventListener('resize', computeInsets);\n\n        return () => {\n            window.removeEventListener('message', handleMessage);\n            window.removeEventListener('resize', computeInsets);\n        };\n    }, []);\n\n    return (\n        <SafeAreaContext.Provider value={insets}>\n            {children}\n        </SafeAreaContext.Provider>\n    );\n}\n\n// ============================================\n// SAFE AREA HOOKS\n// ============================================\n\n/**\n * useSafeArea - Get safe area insets\n * \n * @returns SafeAreaInsets with top, bottom, left, right values in pixels\n */\nexport function useSafeArea(): SafeAreaInsets {\n    return useContext(SafeAreaContext);\n}\n\n// ============================================\n// COLOR SCHEME\n// ============================================\n\nexport type ColorScheme = 'light' | 'dark';\n\n/**\n * useColorScheme - Get current system color scheme\n * \n * @returns 'light' | 'dark'\n */\nexport function useColorScheme(): ColorScheme {\n    const [scheme, setScheme] = useState<ColorScheme>(() =>\n        window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'\n    );\n\n    useEffect(() => {\n        const media = window.matchMedia('(prefers-color-scheme: dark)');\n        const handler = (e: MediaQueryListEvent) => {\n            setScheme(e.matches ? 'dark' : 'light');\n        };\n        media.addEventListener('change', handler);\n        return () => media.removeEventListener('change', handler);\n    }, []);\n\n    return scheme;\n}\n\n// ============================================\n// STATUS BAR\n// ============================================\n\n/**\n * useStatusBar - Control the status bar appearance\n * \n * @param color - Hex color for the status bar\n */\nexport function useStatusBar(color: string): void {\n    useEffect(() => {\n        // Update meta theme-color\n        let meta = document.querySelector('meta[name=\"theme-color\"]');\n        if (!meta) {\n            meta = document.createElement('meta');\n            meta.setAttribute('name', 'theme-color');\n            document.head.appendChild(meta);\n        }\n        meta.setAttribute('content', color);\n\n        // Notify parent Shell\n        window.parent?.postMessage({ type: 'relay:statusbar', color }, '*');\n    }, [color]);\n}\n\n// ============================================\n// BACK HANDLER\n// ============================================\n\n/**\n * useBackHandler - Handle back navigation\n * \n * @param handler - Return true to prevent default back behavior\n */\nexport function useBackHandler(handler: () => boolean): void {\n    useEffect(() => {\n        const handleMessage = (event: MessageEvent) => {\n            if (event.data === 'relay:back') {\n                const handled = handler();\n                if (!handled) {\n                    // Allow default close behavior\n                    window.parent?.postMessage('relay:close', '*');\n                }\n            }\n        };\n\n        // Also handle browser back button\n        const handlePopState = (event: PopStateEvent) => {\n            const handled = handler();\n            if (handled) {\n                // Push a dummy state to prevent navigation\n                window.history.pushState(null, '', window.location.href);\n            }\n        };\n\n        // Push initial state for popstate handling\n        window.history.pushState(null, '', window.location.href);\n\n        window.addEventListener('message', handleMessage);\n        window.addEventListener('popstate', handlePopState);\n\n        return () => {\n            window.removeEventListener('message', handleMessage);\n            window.removeEventListener('popstate', handlePopState);\n        };\n    }, [handler]);\n}\n\n// ============================================\n// APP STATE\n// ============================================\n\nexport type AppState = 'active' | 'background' | 'inactive';\n\n/**\n * useAppState - Track app foreground/background state\n * \n * @returns Current app state\n */\nexport function useAppState(): AppState {\n    const [state, setState] = useState<AppState>('active');\n\n    useEffect(() => {\n        const handleVisibility = () => {\n            setState(document.hidden ? 'background' : 'active');\n        };\n\n        const handleMessage = (event: MessageEvent) => {\n            if (event.data === 'relay:foreground') setState('active');\n            if (event.data === 'relay:background') setState('background');\n        };\n\n        document.addEventListener('visibilitychange', handleVisibility);\n        window.addEventListener('message', handleMessage);\n\n        return () => {\n            document.removeEventListener('visibilitychange', handleVisibility);\n            window.removeEventListener('message', handleMessage);\n        };\n    }, []);\n\n    return state;\n}\n","import { useState, useCallback, useEffect } from 'react';\n\nexport interface NotificationOptions {\n    body?: string;\n    icon?: string;\n    image?: string;\n    badge?: string;\n    tag?: string;\n    data?: any;\n    vibrate?: number[];\n    timestamp?: number;\n    renotify?: boolean;\n    silent?: boolean;\n    requireInteraction?: boolean;\n    actions?: NotificationAction[];\n}\n\nexport interface NotificationAction {\n    action: string;\n    title: string;\n    icon?: string;\n}\n\nexport interface UseNotificationsReturn {\n    permission: NotificationPermission;\n    requestPermission: () => Promise<NotificationPermission>;\n    sendNotification: (title: string, options?: NotificationOptions) => void;\n    scheduleNotification: (title: string, delayMs: number, options?: NotificationOptions) => void;\n    clearBadge: () => Promise<void>;\n    setBadge: (count: number) => Promise<void>;\n}\n\nexport function useNotifications(): UseNotificationsReturn {\n    const [permission, setPermission] = useState<NotificationPermission>('default');\n\n    useEffect(() => {\n        if ('Notification' in window) {\n            setPermission(Notification.permission);\n        }\n    }, []);\n\n    const requestPermission = useCallback(async () => {\n        if (!('Notification' in window)) {\n            console.warn('Notifications not supported');\n            return 'denied';\n        }\n        const perm = await Notification.requestPermission();\n        setPermission(perm);\n        return perm;\n    }, []);\n\n    const sendNotification = useCallback((title: string, options?: NotificationOptions) => {\n        if (!('Notification' in window)) return;\n        \n        // Auto-detect icon if not provided\n        let notificationOptions = options;\n        if (!options?.icon) {\n            // Try to find apple-touch-icon or shortcut icon\n            const iconLink = document.querySelector('link[rel=\"apple-touch-icon\"]') || \n                           document.querySelector('link[rel=\"icon\"]');\n            if (iconLink) {\n                notificationOptions = {\n                    ...options,\n                    icon: (iconLink as HTMLLinkElement).href\n                };\n            }\n        }\n\n        if (Notification.permission === 'granted') {\n            new Notification(title, notificationOptions);\n        } else if (Notification.permission !== 'denied') {\n            Notification.requestPermission().then((perm) => {\n                if (perm === 'granted') {\n                    new Notification(title, notificationOptions);\n                }\n            });\n        }\n    }, []);\n\n    const scheduleNotification = useCallback((title: string, delayMs: number, options?: NotificationOptions) => {\n        setTimeout(() => {\n            sendNotification(title, options);\n        }, delayMs);\n    }, [sendNotification]);\n\n    const setBadge = useCallback(async (count: number) => {\n        if ('setAppBadge' in navigator) {\n            try {\n                await (navigator as any).setAppBadge(count);\n            } catch (e) {\n                console.error('Error setting badge:', e);\n            }\n        }\n    }, []);\n\n    const clearBadge = useCallback(async () => {\n        if ('clearAppBadge' in navigator) {\n            try {\n                await (navigator as any).clearAppBadge();\n            } catch (e) {\n                console.error('Error clearing badge:', e);\n            }\n        }\n    }, []);\n\n    return {\n        permission,\n        requestPermission,\n        sendNotification,\n        scheduleNotification,\n        setBadge,\n        clearBadge\n    };\n}\n"]}