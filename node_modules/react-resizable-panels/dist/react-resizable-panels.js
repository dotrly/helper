"use client";
import { jsx as Q } from "react/jsx-runtime";
import { useState as ee, useCallback as Z, useId as nt, useLayoutEffect as Te, useEffect as Oe, useRef as k, createContext as ot, useImperativeHandle as Ae, useMemo as _e, useSyncExternalStore as it, useContext as rt } from "react";
function b(e, t = "Assertion error") {
  if (!e)
    throw Error(t);
}
function K({
  group: e
}) {
  const { orientation: t, panels: n } = e;
  return n.reduce((o, i) => (o += t === "horizontal" ? i.element.offsetWidth : i.element.offsetHeight, o), 0);
}
function de(e, t) {
  return Array.from(t).sort(
    e === "horizontal" ? st : at
  );
}
function st(e, t) {
  const n = e.element.offsetLeft - t.element.offsetLeft;
  return n !== 0 ? n : e.element.offsetWidth - t.element.offsetWidth;
}
function at(e, t) {
  const n = e.element.offsetTop - t.element.offsetTop;
  return n !== 0 ? n : e.element.offsetHeight - t.element.offsetHeight;
}
function Ne(e) {
  return e !== null && typeof e == "object" && "nodeType" in e && e.nodeType === Node.ELEMENT_NODE;
}
function Fe(e, t) {
  return {
    x: e.x >= t.left && e.x <= t.right ? 0 : Math.min(
      Math.abs(e.x - t.left),
      Math.abs(e.x - t.right)
    ),
    y: e.y >= t.top && e.y <= t.bottom ? 0 : Math.min(
      Math.abs(e.y - t.top),
      Math.abs(e.y - t.bottom)
    )
  };
}
function lt({
  orientation: e,
  rects: t,
  targetRect: n
}) {
  const o = {
    x: n.x + n.width / 2,
    y: n.y + n.height / 2
  };
  let i, r = Number.MAX_VALUE;
  for (const l of t) {
    const { x: s, y: a } = Fe(o, l), u = e === "horizontal" ? s : a;
    u < r && (r = u, i = l);
  }
  return b(i, "No rect found"), i;
}
let ie;
function ut() {
  return ie === void 0 && (typeof matchMedia == "function" ? ie = !!matchMedia("(pointer:coarse)").matches : ie = !1), ie;
}
function $e(e) {
  const { element: t, orientation: n, panels: o, separators: i } = e, r = de(
    n,
    Array.from(t.children).filter(Ne).map((c) => ({ element: c }))
  ).map(({ element: c }) => c), l = [];
  let s = !1, a, u = [];
  for (const c of r)
    if (c.hasAttribute("data-panel")) {
      const h = o.find(
        (S) => S.element === c
      );
      if (h) {
        if (a) {
          const S = a.element.getBoundingClientRect(), m = c.getBoundingClientRect();
          let f;
          if (s) {
            const d = n === "horizontal" ? new DOMRect(S.right, S.top, 0, S.height) : new DOMRect(
              S.left,
              S.bottom,
              S.width,
              0
            ), p = n === "horizontal" ? new DOMRect(m.left, m.top, 0, m.height) : new DOMRect(m.left, m.top, m.width, 0);
            switch (u.length) {
              case 0: {
                f = [
                  d,
                  p
                ];
                break;
              }
              case 1: {
                const g = u[0], v = lt({
                  orientation: n,
                  rects: [S, m],
                  targetRect: g.element.getBoundingClientRect()
                });
                f = [
                  g,
                  v === S ? p : d
                ];
                break;
              }
              default: {
                f = u;
                break;
              }
            }
          } else
            u.length ? f = u : f = [
              n === "horizontal" ? new DOMRect(
                S.right,
                m.top,
                m.left - S.right,
                m.height
              ) : new DOMRect(
                m.left,
                S.bottom,
                m.width,
                m.top - S.bottom
              )
            ];
          for (const d of f) {
            let p = "width" in d ? d : d.element.getBoundingClientRect();
            const g = ut() ? e.resizeTargetMinimumSize.coarse : e.resizeTargetMinimumSize.fine;
            if (p.width < g) {
              const v = g - p.width;
              p = new DOMRect(
                p.x - v / 2,
                p.y,
                p.width + v,
                p.height
              );
            }
            if (p.height < g) {
              const v = g - p.height;
              p = new DOMRect(
                p.x,
                p.y - v / 2,
                p.width,
                p.height + v
              );
            }
            l.push({
              group: e,
              groupSize: K({ group: e }),
              panels: [a, h],
              separator: "width" in d ? void 0 : d,
              rect: p
            });
          }
        }
        s = !1, a = h, u = [];
      }
    } else if (c.hasAttribute("data-separator")) {
      const h = i.find(
        (S) => S.element === c
      );
      h ? u.push(h) : (a = void 0, u = []);
    } else
      s = !0;
  return l;
}
function ct(e, t) {
  const n = getComputedStyle(e), o = parseFloat(n.fontSize);
  return t * o;
}
function ft(e, t) {
  const n = getComputedStyle(e.ownerDocument.body), o = parseFloat(n.fontSize);
  return t * o;
}
function dt(e) {
  return e / 100 * window.innerHeight;
}
function pt(e) {
  return e / 100 * window.innerWidth;
}
function ht(e) {
  switch (typeof e) {
    case "number":
      return [e, "px"];
    case "string": {
      const t = parseFloat(e);
      return e.endsWith("%") ? [t, "%"] : e.endsWith("px") ? [t, "px"] : e.endsWith("rem") ? [t, "rem"] : e.endsWith("em") ? [t, "em"] : e.endsWith("vh") ? [t, "vh"] : e.endsWith("vw") ? [t, "vw"] : [t, "%"];
    }
  }
}
function re({
  groupSize: e,
  panelElement: t,
  styleProp: n
}) {
  let o;
  const [i, r] = ht(n);
  switch (r) {
    case "%": {
      o = i / 100 * e;
      break;
    }
    case "px": {
      o = i;
      break;
    }
    case "rem": {
      o = ft(t, i);
      break;
    }
    case "em": {
      o = ct(t, i);
      break;
    }
    case "vh": {
      o = dt(i);
      break;
    }
    case "vw": {
      o = pt(i);
      break;
    }
  }
  return o;
}
function T(e) {
  return parseFloat(e.toFixed(3));
}
function ve(e) {
  const { panels: t } = e, n = K({ group: e });
  return n === 0 ? t.map((o) => ({
    collapsedSize: 0,
    collapsible: o.panelConstraints.collapsible === !0,
    defaultSize: void 0,
    minSize: 0,
    maxSize: 100,
    panelId: o.id
  })) : t.map((o) => {
    const { element: i, panelConstraints: r } = o;
    let l = 0;
    if (r.collapsedSize !== void 0) {
      const c = re({
        groupSize: n,
        panelElement: i,
        styleProp: r.collapsedSize
      });
      l = T(c / n * 100);
    }
    let s;
    if (r.defaultSize !== void 0) {
      const c = re({
        groupSize: n,
        panelElement: i,
        styleProp: r.defaultSize
      });
      s = T(c / n * 100);
    }
    let a = 0;
    if (r.minSize !== void 0) {
      const c = re({
        groupSize: n,
        panelElement: i,
        styleProp: r.minSize
      });
      a = T(c / n * 100);
    }
    let u = 100;
    if (r.maxSize !== void 0) {
      const c = re({
        groupSize: n,
        panelElement: i,
        styleProp: r.maxSize
      });
      u = T(c / n * 100);
    }
    return {
      collapsedSize: l,
      collapsible: r.collapsible === !0,
      defaultSize: s,
      minSize: a,
      maxSize: u,
      panelId: o.id
    };
  });
}
class mt {
  #e = {};
  addListener(t, n) {
    const o = this.#e[t];
    return o === void 0 ? this.#e[t] = [n] : o.includes(n) || o.push(n), () => {
      this.removeListener(t, n);
    };
  }
  emit(t, n) {
    const o = this.#e[t];
    if (o !== void 0)
      if (o.length === 1)
        o[0].call(null, n);
      else {
        let i = !1, r = null;
        const l = Array.from(o);
        for (let s = 0; s < l.length; s++) {
          const a = l[s];
          try {
            a.call(null, n);
          } catch (u) {
            r === null && (i = !0, r = u);
          }
        }
        if (i)
          throw r;
      }
  }
  removeAllListeners() {
    this.#e = {};
  }
  removeListener(t, n) {
    const o = this.#e[t];
    if (o !== void 0) {
      const i = o.indexOf(n);
      i >= 0 && o.splice(i, 1);
    }
  }
}
function R(e, t, n = 0) {
  return Math.abs(T(e) - T(t)) <= n;
}
let I = {
  cursorFlags: 0,
  interactionState: {
    state: "inactive"
  },
  mountedGroups: /* @__PURE__ */ new Map()
};
const F = new mt();
function G() {
  return I;
}
function M(e) {
  const t = typeof e == "function" ? e(I) : e;
  if (I === t)
    return I;
  const n = I;
  return I = {
    ...I,
    ...t
  }, t.cursorFlags !== void 0 && F.emit("cursorFlagsChange", I.cursorFlags), t.interactionState !== void 0 && F.emit("interactionStateChange", I.interactionState), t.mountedGroups !== void 0 && (I.mountedGroups.forEach((o, i) => {
    o.derivedPanelConstraints.forEach((r) => {
      if (r.collapsible) {
        const { layout: l } = n.mountedGroups.get(i) ?? {};
        if (l) {
          const s = R(
            r.collapsedSize,
            o.layout[r.panelId]
          ), a = R(
            r.collapsedSize,
            l[r.panelId]
          );
          s && !a && (i.inMemoryLastExpandedPanelSizes[r.panelId] = l[r.panelId]);
        }
      }
    });
  }), F.emit("mountedGroupsChange", I.mountedGroups)), I;
}
function gt(e, t, n) {
  let o, i = {
    x: 1 / 0,
    y: 1 / 0
  };
  for (const r of t) {
    const l = Fe(n, r.rect);
    switch (e) {
      case "horizontal": {
        l.x <= i.x && (o = r, i = l);
        break;
      }
      case "vertical": {
        l.y <= i.y && (o = r, i = l);
        break;
      }
    }
  }
  return o ? {
    distance: i,
    hitRegion: o
  } : void 0;
}
function yt(e) {
  return e !== null && typeof e == "object" && "nodeType" in e && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
}
function St(e, t) {
  if (e === t) throw new Error("Cannot compare node with itself");
  const n = {
    a: be(e),
    b: be(t)
  };
  let o;
  for (; n.a.at(-1) === n.b.at(-1); )
    o = n.a.pop(), n.b.pop();
  b(
    o,
    "Stacking order can only be calculated for elements with a common ancestor"
  );
  const i = {
    a: ze(xe(n.a)),
    b: ze(xe(n.b))
  };
  if (i.a === i.b) {
    const r = o.childNodes, l = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let s = r.length;
    for (; s--; ) {
      const a = r[s];
      if (a === l.a) return 1;
      if (a === l.b) return -1;
    }
  }
  return Math.sign(i.a - i.b);
}
const vt = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function xt(e) {
  const t = getComputedStyle(He(e) ?? e).display;
  return t === "flex" || t === "inline-flex";
}
function zt(e) {
  const t = getComputedStyle(e);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || xt(e)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || vt.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function xe(e) {
  let t = e.length;
  for (; t--; ) {
    const n = e[t];
    if (b(n, "Missing node"), zt(n)) return n;
  }
  return null;
}
function ze(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function be(e) {
  const t = [];
  for (; e; )
    t.push(e), e = He(e);
  return t;
}
function He(e) {
  const { parentNode: t } = e;
  return yt(t) ? t.host : t;
}
function bt(e, t) {
  return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
}
function wt({
  groupElement: e,
  hitRegion: t,
  pointerEventTarget: n
}) {
  if (!Ne(n) || n.contains(e) || e.contains(n))
    return !0;
  if (St(n, e) > 0) {
    let o = n;
    for (; o; ) {
      if (o.contains(e))
        return !0;
      if (bt(o.getBoundingClientRect(), t))
        return !1;
      o = o.parentElement;
    }
  }
  return !0;
}
function pe(e, t) {
  const n = [];
  return t.forEach((o, i) => {
    if (i.disabled)
      return;
    const r = $e(i), l = gt(i.orientation, r, {
      x: e.clientX,
      y: e.clientY
    });
    l && l.distance.x <= 0 && l.distance.y <= 0 && wt({
      groupElement: i.element,
      hitRegion: l.hitRegion.rect,
      pointerEventTarget: e.target
    }) && n.push(l.hitRegion);
  }), n;
}
function Lt(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] != t[n])
      return !1;
  return !0;
}
function D(e, t) {
  return R(e, t) ? 0 : e > t ? 1 : -1;
}
function B({
  panelConstraints: e,
  size: t
}) {
  const {
    collapsedSize: n = 0,
    collapsible: o,
    maxSize: i = 100,
    minSize: r = 0
  } = e;
  if (D(t, r) < 0)
    if (o) {
      const l = (n + r) / 2;
      D(t, l) < 0 ? t = n : t = r;
    } else
      t = r;
  return t = Math.min(i, t), t = T(t), t;
}
function te({
  delta: e,
  initialLayout: t,
  panelConstraints: n,
  pivotIndices: o,
  prevLayout: i,
  trigger: r
}) {
  if (R(e, 0))
    return t;
  const l = Object.values(t), s = Object.values(i), a = [...l], [u, c] = o;
  b(u != null, "Invalid first pivot index"), b(c != null, "Invalid second pivot index");
  let h = 0;
  switch (r) {
    case "keyboard": {
      {
        const f = e < 0 ? c : u, d = n[f];
        b(
          d,
          `Panel constraints not found for index ${f}`
        );
        const {
          collapsedSize: p = 0,
          collapsible: g,
          minSize: v = 0
        } = d;
        if (g) {
          const x = l[f];
          if (b(
            x != null,
            `Previous layout not found for panel index ${f}`
          ), R(x, p)) {
            const y = v - x;
            D(y, Math.abs(e)) > 0 && (e = e < 0 ? 0 - y : y);
          }
        }
      }
      {
        const f = e < 0 ? u : c, d = n[f];
        b(
          d,
          `No panel constraints found for index ${f}`
        );
        const {
          collapsedSize: p = 0,
          collapsible: g,
          minSize: v = 0
        } = d;
        if (g) {
          const x = l[f];
          if (b(
            x != null,
            `Previous layout not found for panel index ${f}`
          ), R(x, v)) {
            const y = x - p;
            D(y, Math.abs(e)) > 0 && (e = e < 0 ? 0 - y : y);
          }
        }
      }
      break;
    }
    default: {
      const f = e < 0 ? c : u, d = n[f];
      b(
        d,
        `Panel constraints not found for index ${f}`
      );
      const { collapsible: p, collapsedSize: g, minSize: v } = d;
      if (p) {
        const x = f === c;
        if (e > 0) {
          const y = v - g, z = y / 2;
          D(e, v) < 0 && (e = D(e, z) <= 0 ? 0 : y);
        } else {
          const y = v - g, z = 100 - y / 2;
          x ? D(Math.abs(e), v) < 0 && (e = D(100 + e, z) > 0 ? 0 : -y) : D(100 + e, v) < 0 && (e = D(100 + e, z) > 0 ? 0 : -y);
        }
      }
      break;
    }
  }
  {
    const f = e < 0 ? 1 : -1;
    let d = e < 0 ? c : u, p = 0;
    for (; ; ) {
      const v = l[d];
      b(
        v != null,
        `Previous layout not found for panel index ${d}`
      );
      const y = B({
        panelConstraints: n[d],
        size: 100
      }) - v;
      if (p += y, d += f, d < 0 || d >= n.length)
        break;
    }
    const g = Math.min(Math.abs(e), Math.abs(p));
    e = e < 0 ? 0 - g : g;
  }
  {
    let d = e < 0 ? u : c;
    for (; d >= 0 && d < n.length; ) {
      const p = Math.abs(e) - Math.abs(h), g = l[d];
      b(
        g != null,
        `Previous layout not found for panel index ${d}`
      );
      const v = g - p, x = B({
        panelConstraints: n[d],
        size: v
      });
      if (!R(g, x) && (h += g - x, a[d] = x, h.toFixed(3).localeCompare(Math.abs(e).toFixed(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      e < 0 ? d-- : d++;
    }
  }
  if (Lt(s, a))
    return i;
  {
    const f = e < 0 ? c : u, d = l[f];
    b(
      d != null,
      `Previous layout not found for panel index ${f}`
    );
    const p = d + h, g = B({
      panelConstraints: n[f],
      size: p
    });
    if (a[f] = g, !R(g, p)) {
      let v = p - g, y = e < 0 ? c : u;
      for (; y >= 0 && y < n.length; ) {
        const z = a[y];
        b(
          z != null,
          `Previous layout not found for panel index ${y}`
        );
        const C = z + v, P = B({
          panelConstraints: n[y],
          size: C
        });
        if (R(z, P) || (v -= P - z, a[y] = P), R(v, 0))
          break;
        e > 0 ? y-- : y++;
      }
    }
  }
  const S = Object.values(a).reduce(
    (f, d) => d + f,
    0
  );
  if (!R(S, 100, 0.1))
    return i;
  const m = Object.keys(i);
  return a.reduce((f, d, p) => (f[m[p]] = d, f), {});
}
function $(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length)
    return !1;
  for (const n in e)
    if (t[n] === void 0 || D(e[n], t[n]) !== 0)
      return !1;
  return !0;
}
function H({
  layout: e,
  panelConstraints: t
}) {
  const o = [...Object.values(e)], i = o.reduce(
    (s, a) => s + a,
    0
  );
  if (o.length !== t.length)
    throw Error(
      `Invalid ${t.length} panel layout: ${o.map((s) => `${s}%`).join(", ")}`
    );
  if (!R(i, 100) && o.length > 0)
    for (let s = 0; s < t.length; s++) {
      const a = o[s];
      b(a != null, `No layout data found for index ${s}`);
      const u = 100 / i * a;
      o[s] = u;
    }
  let r = 0;
  for (let s = 0; s < t.length; s++) {
    const a = o[s];
    b(a != null, `No layout data found for index ${s}`);
    const u = B({
      panelConstraints: t[s],
      size: a
    });
    a != u && (r += a - u, o[s] = u);
  }
  if (!R(r, 0))
    for (let s = 0; s < t.length; s++) {
      const a = o[s];
      b(a != null, `No layout data found for index ${s}`);
      const u = a + r, c = B({
        panelConstraints: t[s],
        size: u
      });
      if (a !== c && (r -= c - a, o[s] = c, R(r, 0)))
        break;
    }
  const l = Object.keys(e);
  return o.reduce((s, a, u) => (s[l[u]] = a, s), {});
}
function je({
  groupId: e,
  panelId: t
}) {
  const n = () => {
    const { mountedGroups: s } = G();
    for (const [
      a,
      {
        defaultLayoutDeferred: u,
        derivedPanelConstraints: c,
        layout: h,
        separatorToPanels: S
      }
    ] of s)
      if (a.id === e)
        return {
          defaultLayoutDeferred: u,
          derivedPanelConstraints: c,
          group: a,
          layout: h,
          separatorToPanels: S
        };
    throw Error(`Group ${e} not found`);
  }, o = () => {
    const s = n().derivedPanelConstraints.find(
      (a) => a.panelId === t
    );
    if (s !== void 0)
      return s;
    throw Error(`Panel constraints not found for Panel ${t}`);
  }, i = () => {
    const s = n().group.panels.find((a) => a.id === t);
    if (s !== void 0)
      return s;
    throw Error(`Layout not found for Panel ${t}`);
  }, r = () => {
    const s = n().layout[t];
    if (s !== void 0)
      return s;
    throw Error(`Layout not found for Panel ${t}`);
  }, l = (s) => {
    const a = r();
    if (s === a)
      return;
    const {
      defaultLayoutDeferred: u,
      derivedPanelConstraints: c,
      group: h,
      layout: S,
      separatorToPanels: m
    } = n(), f = h.panels.findIndex((v) => v.id === t), d = f === h.panels.length - 1, p = te({
      delta: d ? a - s : s - a,
      initialLayout: S,
      panelConstraints: c,
      pivotIndices: d ? [f - 1, f] : [f, f + 1],
      prevLayout: S,
      trigger: "imperative-api"
    }), g = H({
      layout: p,
      panelConstraints: c
    });
    $(S, g) || M((v) => ({
      mountedGroups: new Map(v.mountedGroups).set(h, {
        defaultLayoutDeferred: u,
        derivedPanelConstraints: c,
        layout: g,
        separatorToPanels: m
      })
    }));
  };
  return {
    collapse: () => {
      const { collapsible: s, collapsedSize: a } = o(), { mutableValues: u } = i(), c = r();
      s && c !== a && (u.expandToSize = c, l(a));
    },
    expand: () => {
      const { collapsible: s, collapsedSize: a, minSize: u } = o(), { mutableValues: c } = i(), h = r();
      if (s && h === a) {
        let S = c.expandToSize ?? u;
        S === 0 && (S = 1), l(S);
      }
    },
    getSize: () => {
      const { group: s } = n(), a = r(), { element: u } = i(), c = s.orientation === "horizontal" ? u.offsetWidth : u.offsetHeight;
      return {
        asPercentage: a,
        inPixels: c
      };
    },
    isCollapsed: () => {
      const { collapsible: s, collapsedSize: a } = o(), u = r();
      return s && R(a, u);
    },
    resize: (s) => {
      if (r() !== s) {
        let u;
        switch (typeof s) {
          case "number": {
            const { group: c } = n(), h = K({ group: c });
            u = T(s / h * 100);
            break;
          }
          case "string": {
            u = parseFloat(s);
            break;
          }
        }
        l(u);
      }
    }
  };
}
function we(e) {
  if (e.defaultPrevented)
    return;
  const { mountedGroups: t } = G();
  pe(e, t).forEach((o) => {
    if (o.separator) {
      const i = o.panels.find(
        (r) => r.panelConstraints.defaultSize !== void 0
      );
      if (i) {
        const r = i.panelConstraints.defaultSize, l = je({
          groupId: o.group.id,
          panelId: i.id
        });
        l && r !== void 0 && (l.resize(r), e.preventDefault());
      }
    }
  });
}
function ae(e) {
  const { mountedGroups: t } = G();
  for (const [n] of t)
    if (n.separators.some(
      (o) => o.element === e
    ))
      return n;
  throw Error("Could not find parent Group for separator element");
}
function Ve({
  groupId: e
}) {
  const t = () => {
    const { mountedGroups: n } = G();
    for (const [o, i] of n)
      if (o.id === e)
        return { group: o, ...i };
    throw Error(`Could not find Group with id "${e}"`);
  };
  return {
    getLayout() {
      const { defaultLayoutDeferred: n, layout: o } = t();
      return n ? {} : o;
    },
    setLayout(n) {
      const {
        defaultLayoutDeferred: o,
        derivedPanelConstraints: i,
        group: r,
        layout: l,
        separatorToPanels: s
      } = t(), a = H({
        layout: n,
        panelConstraints: i
      });
      return o ? l : ($(l, a) || M((u) => ({
        mountedGroups: new Map(u.mountedGroups).set(r, {
          defaultLayoutDeferred: o,
          derivedPanelConstraints: i,
          layout: a,
          separatorToPanels: s
        })
      })), a);
    }
  };
}
function Ue(e) {
  const { mountedGroups: t } = G(), n = t.get(e);
  return b(n, `Mounted Group ${e.id} not found`), n;
}
function N(e, t) {
  const n = ae(e), o = Ue(n), i = n.separators.find(
    (h) => h.element === e
  );
  b(i, "Matching separator not found");
  const r = o.separatorToPanels.get(i);
  b(r, "Matching panels not found");
  const l = r.map((h) => n.panels.indexOf(h)), a = Ve({ groupId: n.id }).getLayout(), u = te({
    delta: t,
    initialLayout: a,
    panelConstraints: o.derivedPanelConstraints,
    pivotIndices: l,
    prevLayout: a,
    trigger: "keyboard"
  }), c = H({
    layout: u,
    panelConstraints: o.derivedPanelConstraints
  });
  $(a, c) || M((h) => ({
    mountedGroups: new Map(h.mountedGroups).set(n, {
      defaultLayoutDeferred: o.defaultLayoutDeferred,
      derivedPanelConstraints: o.derivedPanelConstraints,
      layout: c,
      separatorToPanels: o.separatorToPanels
    })
  }));
}
function Le(e) {
  if (e.defaultPrevented)
    return;
  const t = e.currentTarget, n = ae(t);
  if (!n.disabled)
    switch (e.key) {
      case "ArrowDown": {
        e.preventDefault(), n.orientation === "vertical" && N(t, 5);
        break;
      }
      case "ArrowLeft": {
        e.preventDefault(), n.orientation === "horizontal" && N(t, -5);
        break;
      }
      case "ArrowRight": {
        e.preventDefault(), n.orientation === "horizontal" && N(t, 5);
        break;
      }
      case "ArrowUp": {
        e.preventDefault(), n.orientation === "vertical" && N(t, -5);
        break;
      }
      case "End": {
        e.preventDefault(), N(t, 100);
        break;
      }
      case "Enter": {
        e.preventDefault();
        const o = ae(t), { derivedPanelConstraints: i, layout: r, separatorToPanels: l } = Ue(o), s = o.separators.find(
          (h) => h.element === t
        );
        b(s, "Matching separator not found");
        const a = l.get(s);
        b(a, "Matching panels not found");
        const u = a[0], c = i.find(
          (h) => h.panelId === u.id
        );
        if (b(c, "Panel metadata not found"), c.collapsible) {
          const h = r[u.id], S = c.collapsedSize === h ? o.inMemoryLastExpandedPanelSizes[u.id] ?? c.minSize : c.collapsedSize;
          N(t, S - h);
        }
        break;
      }
      case "F6": {
        e.preventDefault();
        const i = ae(t).separators.map(
          (a) => a.element
        ), r = Array.from(i).findIndex(
          (a) => a === e.currentTarget
        );
        b(r !== null, "Index not found");
        const l = e.shiftKey ? r > 0 ? r - 1 : i.length - 1 : r + 1 < i.length ? r + 1 : 0;
        i[l].focus();
        break;
      }
      case "Home": {
        e.preventDefault(), N(t, -100);
        break;
      }
    }
}
function Ce(e) {
  if (e.defaultPrevented)
    return;
  if (e.pointerType === "mouse" && e.button > 0)
    return;
  const { mountedGroups: t } = G(), n = pe(e, t), o = /* @__PURE__ */ new Map();
  let i = !1;
  n.forEach((r) => {
    r.separator && (i || (i = !0, r.separator.element.focus()));
    const l = t.get(r.group);
    l && o.set(r.group, l.layout);
  }), M({
    interactionState: {
      hitRegions: n,
      initialLayoutMap: o,
      pointerDownAtPoint: { x: e.clientX, y: e.clientY },
      state: "active"
    }
  }), n.length && e.preventDefault();
}
const Ct = (e) => e, ce = () => {
}, We = 1, Be = 2, Ke = 4, Xe = 8, Pe = 3, Re = 12;
let se;
function Me() {
  return se === void 0 && (se = !1, typeof window < "u" && (window.navigator.userAgent.includes("Chrome") || window.navigator.userAgent.includes("Firefox")) && (se = !0)), se;
}
function Pt({
  cursorFlags: e,
  groups: t,
  state: n
}) {
  let o = 0, i = 0;
  switch (n) {
    case "active":
    case "hover":
      t.forEach((r) => {
        if (!r.disableCursor)
          switch (r.orientation) {
            case "horizontal": {
              o++;
              break;
            }
            case "vertical": {
              i++;
              break;
            }
          }
      });
  }
  if (o === 0 && i === 0)
    return null;
  switch (n) {
    case "active": {
      if (e && Me()) {
        const r = (e & We) !== 0, l = (e & Be) !== 0, s = (e & Ke) !== 0, a = (e & Xe) !== 0;
        if (r)
          return s ? "se-resize" : a ? "ne-resize" : "e-resize";
        if (l)
          return s ? "sw-resize" : a ? "nw-resize" : "w-resize";
        if (s)
          return "s-resize";
        if (a)
          return "n-resize";
      }
      break;
    }
  }
  return Me() ? o > 0 && i > 0 ? "move" : o > 0 ? "ew-resize" : "ns-resize" : o > 0 && i > 0 ? "grab" : o > 0 ? "col-resize" : "row-resize";
}
const Ee = /* @__PURE__ */ new WeakMap();
function he(e) {
  if (e.defaultView === null || e.defaultView === void 0)
    return;
  let { prevStyle: t, styleSheet: n } = Ee.get(e) ?? {};
  n === void 0 && (n = new e.defaultView.CSSStyleSheet(), e.adoptedStyleSheets.push(n));
  const { cursorFlags: o, interactionState: i } = G();
  switch (i.state) {
    case "active":
    case "hover": {
      const r = Pt({
        cursorFlags: o,
        groups: i.hitRegions.map((s) => s.group),
        state: i.state
      }), l = `*, *:hover {cursor: ${r} !important; ${i.state === "active" ? "touch-action: none;" : ""} }`;
      if (t === l)
        return;
      t = l, r ? n.cssRules.length === 0 ? n.insertRule(l) : n.replaceSync(l) : n.cssRules.length === 1 && n.deleteRule(0);
      break;
    }
    case "inactive": {
      t = void 0, n.cssRules.length === 1 && n.deleteRule(0);
      break;
    }
  }
  Ee.set(e, {
    prevStyle: t,
    styleSheet: n
  });
}
function qe({
  document: e,
  event: t,
  hitRegions: n,
  initialLayoutMap: o,
  mountedGroups: i,
  pointerDownAtPoint: r,
  prevCursorFlags: l
}) {
  let s = 0;
  const a = new Map(i);
  n.forEach((c) => {
    const { group: h, groupSize: S } = c, { disableCursor: m, orientation: f, panels: d } = h;
    let p = 0;
    r ? f === "horizontal" ? p = (t.clientX - r.x) / S * 100 : p = (t.clientY - r.y) / S * 100 : f === "horizontal" ? p = t.clientX < 0 ? -100 : 100 : p = t.clientY < 0 ? -100 : 100;
    const g = o.get(h), {
      defaultLayoutDeferred: v,
      derivedPanelConstraints: x,
      layout: y,
      separatorToPanels: z
    } = i.get(h) ?? { defaultLayoutDeferred: !1 };
    if (x && g && y && z) {
      const C = te({
        delta: p,
        initialLayout: g,
        panelConstraints: x,
        pivotIndices: c.panels.map((P) => d.indexOf(P)),
        prevLayout: y,
        trigger: "mouse-or-touch"
      });
      if ($(C, y)) {
        if (p !== 0 && !m)
          switch (f) {
            case "horizontal": {
              s |= p < 0 ? We : Be;
              break;
            }
            case "vertical": {
              s |= p < 0 ? Ke : Xe;
              break;
            }
          }
      } else {
        a.set(c.group, {
          defaultLayoutDeferred: v,
          derivedPanelConstraints: x,
          layout: C,
          separatorToPanels: z
        });
        const P = c.group.panels.map(({ id: O }) => O).join(",");
        c.group.inMemoryLayouts[P] = C;
      }
    }
  });
  let u = 0;
  t.movementX === 0 ? u |= l & Pe : u |= s & Pe, t.movementY === 0 ? u |= l & Re : u |= s & Re, M({
    cursorFlags: u,
    mountedGroups: a
  }), he(e);
}
function ke(e) {
  const { cursorFlags: t, interactionState: n, mountedGroups: o } = G();
  switch (n.state) {
    case "active":
      qe({
        document: e.currentTarget,
        event: e,
        hitRegions: n.hitRegions,
        initialLayoutMap: n.initialLayoutMap,
        mountedGroups: o,
        prevCursorFlags: t
      });
  }
}
function Ge(e) {
  if (e.defaultPrevented)
    return;
  const { cursorFlags: t, interactionState: n, mountedGroups: o } = G();
  switch (n.state) {
    case "active": {
      if (
        // Skip this check for "pointerleave" events, else Firefox triggers a false positive (see #514)
        e.buttons === 0
      ) {
        M(
          (i) => i.interactionState.state === "inactive" ? i : {
            cursorFlags: 0,
            interactionState: { state: "inactive" }
          }
        ), M((i) => ({
          mountedGroups: new Map(i.mountedGroups)
        }));
        return;
      }
      qe({
        document: e.currentTarget,
        event: e,
        hitRegions: n.hitRegions,
        initialLayoutMap: n.initialLayoutMap,
        mountedGroups: o,
        pointerDownAtPoint: n.pointerDownAtPoint,
        prevCursorFlags: t
      });
      break;
    }
    default: {
      const i = pe(e, o);
      i.length === 0 ? n.state !== "inactive" && M({
        interactionState: {
          state: "inactive"
        }
      }) : M({
        interactionState: {
          hitRegions: i,
          state: "hover"
        }
      }), he(e.currentTarget);
      break;
    }
  }
}
function Ie(e) {
  if (e.defaultPrevented)
    return;
  if (e.pointerType === "mouse" && e.button > 0)
    return;
  const { interactionState: t } = G();
  switch (t.state) {
    case "active":
      M({
        cursorFlags: 0,
        interactionState: {
          state: "inactive"
        }
      }), t.hitRegions.length > 0 && (he(e.currentTarget), M((n) => ({
        mountedGroups: new Map(n.mountedGroups)
      })), e.preventDefault());
  }
}
function De(e) {
  let t = 0, n = 0;
  const o = {};
  for (const r of e)
    if (r.defaultSize !== void 0) {
      t++;
      const l = T(r.defaultSize);
      n += l, o[r.panelId] = l;
    } else
      o[r.panelId] = void 0;
  const i = e.length - t;
  if (i !== 0) {
    const r = T((100 - n) / i);
    for (const l of e)
      l.defaultSize === void 0 && (o[l.panelId] = r);
  }
  return o;
}
function Rt(e, t, n) {
  if (!n[0])
    return;
  const i = e.panels.find((u) => u.element === t);
  if (!i || !i.onResize)
    return;
  const r = K({ group: e }), l = e.orientation === "horizontal" ? i.element.offsetWidth : i.element.offsetHeight, s = i.mutableValues.prevSize, a = {
    asPercentage: T(l / r * 100),
    inPixels: l
  };
  i.mutableValues.prevSize = a, i.onResize(a, i.id, s);
}
function Mt(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length)
    return !1;
  for (const o in e)
    if (e[o] !== t[o])
      return !1;
  return !0;
}
function Et(e, t) {
  const n = e.map((i) => i.id), o = Object.keys(t);
  if (n.length !== o.length)
    return !1;
  for (const i of n)
    if (!o.includes(i))
      return !1;
  return !0;
}
const W = /* @__PURE__ */ new Map();
function kt(e) {
  let t = !0;
  b(
    e.element.ownerDocument.defaultView,
    "Cannot register an unmounted Group"
  );
  const n = e.element.ownerDocument.defaultView.ResizeObserver, o = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), r = new n((f) => {
    for (const d of f) {
      const { borderBoxSize: p, target: g } = d;
      if (g === e.element) {
        if (t) {
          if (K({ group: e }) === 0)
            return;
          M((x) => {
            const y = x.mountedGroups.get(e);
            if (y) {
              const z = ve(e), C = y.defaultLayoutDeferred ? De(z) : y.layout, P = H({
                layout: C,
                panelConstraints: z
              });
              return !y.defaultLayoutDeferred && $(C, P) && Mt(
                y.derivedPanelConstraints,
                z
              ) ? x : {
                mountedGroups: new Map(x.mountedGroups).set(e, {
                  defaultLayoutDeferred: !1,
                  derivedPanelConstraints: z,
                  layout: P,
                  separatorToPanels: y.separatorToPanels
                })
              };
            }
            return x;
          });
        }
      } else
        Rt(e, g, p);
    }
  });
  r.observe(e.element), e.panels.forEach((f) => {
    b(
      !o.has(f.id),
      `Panel ids must be unique; id "${f.id}" was used more than once`
    ), o.add(f.id), f.onResize && r.observe(f.element);
  });
  const l = K({ group: e }), s = ve(e), a = e.panels.map(({ id: f }) => f).join(",");
  let u = e.defaultLayout;
  u && (Et(e.panels, u) || (u = void 0));
  const c = e.inMemoryLayouts[a] ?? u ?? De(s), h = H({
    layout: c,
    panelConstraints: s
  }), S = $e(e), m = e.element.ownerDocument;
  return M((f) => {
    const d = /* @__PURE__ */ new Map();
    return W.set(
      m,
      (W.get(m) ?? 0) + 1
    ), S.forEach((p) => {
      p.separator && d.set(p.separator, p.panels);
    }), {
      mountedGroups: new Map(f.mountedGroups).set(e, {
        defaultLayoutDeferred: l === 0,
        derivedPanelConstraints: s,
        layout: h,
        separatorToPanels: d
      })
    };
  }), e.separators.forEach((f) => {
    b(
      !i.has(f.id),
      `Separator ids must be unique; id "${f.id}" was used more than once`
    ), i.add(f.id), f.element.addEventListener("keydown", Le);
  }), W.get(m) === 1 && (m.addEventListener("dblclick", we, !0), m.addEventListener("pointerdown", Ce, !0), m.addEventListener("pointerleave", ke), m.addEventListener("pointermove", Ge), m.addEventListener("pointerup", Ie, !0)), function() {
    t = !1, W.set(
      m,
      Math.max(0, (W.get(m) ?? 0) - 1)
    ), M((d) => {
      const p = new Map(d.mountedGroups);
      return p.delete(e), { mountedGroups: p };
    }), e.separators.forEach((d) => {
      d.element.removeEventListener("keydown", Le);
    }), W.get(m) || (m.removeEventListener(
      "dblclick",
      we,
      !0
    ), m.removeEventListener(
      "pointerdown",
      Ce,
      !0
    ), m.removeEventListener("pointerleave", ke), m.removeEventListener("pointermove", Ge), m.removeEventListener("pointerup", Ie, !0)), r.disconnect();
  };
}
function Ye() {
  const [e, t] = ee({}), n = Z(() => t({}), []);
  return [e, n];
}
function me(e) {
  const t = nt();
  return `${e ?? t}`;
}
const j = typeof window < "u" ? Te : Oe;
function J(e) {
  const t = k(e);
  return j(() => {
    t.current = e;
  }, [e]), Z(
    (...n) => t.current?.(...n),
    [t]
  );
}
function ge(...e) {
  return J((t) => {
    e.forEach((n) => {
      if (n)
        switch (typeof n) {
          case "function": {
            n(t);
            break;
          }
          case "object": {
            n.current = t;
            break;
          }
        }
    });
  });
}
function Gt(e) {
  const t = k({ ...e });
  return j(() => {
    for (const n in e)
      t.current[n] = e[n];
  }, [e]), t.current;
}
const Ze = ot(null);
function It(e, t) {
  const n = k({
    getLayout: () => ({}),
    setLayout: Ct
  });
  Ae(t, () => n.current, []), j(() => {
    Object.assign(
      n.current,
      Ve({ groupId: e })
    );
  });
}
function Dt({
  children: e,
  className: t,
  defaultLayout: n,
  disableCursor: o,
  disabled: i,
  elementRef: r,
  groupRef: l,
  id: s,
  onLayoutChange: a,
  onLayoutChanged: u,
  orientation: c = "horizontal",
  resizeTargetMinimumSize: h = {
    coarse: 20,
    fine: 10
  },
  style: S,
  ...m
}) {
  const f = k({
    onLayoutChange: {},
    onLayoutChanged: {}
  }), d = J((w) => {
    $(f.current.onLayoutChange, w) || (f.current.onLayoutChange = w, a?.(w));
  }), p = J((w) => {
    $(f.current.onLayoutChanged, w) || (f.current.onLayoutChanged = w, u?.(w));
  }), g = me(s), v = k(null), [x, y] = Ye(), z = k({
    lastExpandedPanelSizes: {},
    layouts: {},
    panels: [],
    resizeTargetMinimumSize: h,
    separators: []
  }), C = ge(v, r);
  It(g, l);
  const P = J(
    (w, L) => {
      const { interactionState: E, mountedGroups: ne } = G();
      for (const oe of ne.keys())
        if (oe.id === w) {
          const X = ne.get(oe);
          if (X) {
            let q = !1;
            switch (E.state) {
              case "active": {
                q = E.hitRegions.some(
                  (le) => le.group === oe
                );
                break;
              }
            }
            return {
              flexGrow: X.layout[L] ?? 1,
              pointerEvents: q ? "none" : void 0
            };
          }
        }
      return {
        flexGrow: n?.[L] ?? 1
      };
    }
  ), O = _e(
    () => ({
      getPanelStyles: P,
      id: g,
      orientation: c,
      registerPanel: (w) => {
        const L = z.current;
        return L.panels = de(c, [
          ...L.panels,
          w
        ]), y(), () => {
          L.panels = L.panels.filter(
            (E) => E !== w
          ), y();
        };
      },
      registerSeparator: (w) => {
        const L = z.current;
        return L.separators = de(c, [
          ...L.separators,
          w
        ]), y(), () => {
          L.separators = L.separators.filter(
            (E) => E !== w
          ), y();
        };
      }
    }),
    [P, g, y, c]
  ), V = Gt({
    defaultLayout: n,
    disableCursor: o
  }), A = k(null);
  return j(() => {
    const w = v.current;
    if (w === null)
      return;
    const L = z.current, E = {
      defaultLayout: V.defaultLayout,
      disableCursor: !!V.disableCursor,
      disabled: !!i,
      element: w,
      id: g,
      inMemoryLastExpandedPanelSizes: z.current.lastExpandedPanelSizes,
      inMemoryLayouts: z.current.layouts,
      orientation: c,
      panels: L.panels,
      resizeTargetMinimumSize: L.resizeTargetMinimumSize,
      separators: L.separators
    };
    A.current = E;
    const ne = kt(E), X = G().mountedGroups.get(E);
    if (X) {
      const { defaultLayoutDeferred: Y, derivedPanelConstraints: _, layout: U } = X;
      !Y && _.length > 0 && (d(U), p(U), L.panels.forEach((ue) => {
        ue.scheduleUpdate();
      }));
    }
    let q = !1;
    const le = F.addListener(
      "interactionStateChange",
      (Y) => {
        const _ = Y.state === "active";
        q !== _ && (q = _, L.panels.forEach((U) => {
          U.scheduleUpdate();
        }));
      }
    ), Je = F.addListener(
      "mountedGroupsChange",
      (Y) => {
        const _ = Y.get(E);
        if (_) {
          const { defaultLayoutDeferred: U, derivedPanelConstraints: ue, layout: Se } = _;
          if (U || ue.length === 0)
            return;
          const { interactionState: Qe } = G(), et = Qe.state !== "active";
          d(Se), et && p(Se), L.panels.forEach((tt) => {
            tt.scheduleUpdate();
          });
        }
      }
    );
    return () => {
      A.current = null, ne(), le(), Je();
    };
  }, [
    i,
    g,
    p,
    d,
    c,
    x,
    V
  ]), Oe(() => {
    const w = A.current;
    w && (w.defaultLayout = n, w.disableCursor = !!o);
  }), /* @__PURE__ */ Q(Ze.Provider, { value: O, children: /* @__PURE__ */ Q(
    "div",
    {
      ...m,
      className: t,
      "data-group": !0,
      "data-testid": g,
      id: g,
      ref: C,
      style: {
        height: "100%",
        width: "100%",
        overflow: "hidden",
        ...S,
        display: "flex",
        flexDirection: c === "horizontal" ? "row" : "column",
        flexWrap: "nowrap"
      },
      children: e
    }
  ) });
}
Dt.displayName = "Group";
function fe(e, t) {
  return `react-resizable-panels:${[e, ...t].join(":")}`;
}
function jt({
  debounceSaveMs: e = 100,
  panelIds: t,
  storage: n = localStorage,
  ...o
}) {
  const i = t !== void 0, r = "id" in o ? o.id : o.groupId, l = fe(r, t ?? []), s = it(
    Tt,
    () => n.getItem(l),
    () => n.getItem(l)
  ), a = _e(
    () => s ? JSON.parse(s) : void 0,
    [s]
  ), u = k(null), c = Z(() => {
    const m = u.current;
    m && (u.current = null, clearTimeout(m));
  }, []);
  Te(() => () => {
    c();
  }, [c]);
  const h = Z(
    (m) => {
      c();
      let f;
      i ? f = fe(r, Object.keys(m)) : f = fe(r, []);
      try {
        n.setItem(f, JSON.stringify(m));
      } catch (d) {
        console.error(d);
      }
    },
    [c, i, r, n]
  ), S = Z(
    (m) => {
      c(), e === 0 ? h(m) : u.current = setTimeout(() => {
        h(m);
      }, e);
    },
    [c, e, h]
  );
  return {
    /**
     * Pass this value to `Group` as the `defaultLayout` prop.
     */
    defaultLayout: a,
    /**
     * Attach this callback on the `Group` as the `onLayoutChange` prop.
     *
     * @deprecated Use the {@link onLayoutChanged} prop instead.
     */
    onLayoutChange: S,
    /**
     * Attach this callback on the `Group` as the `onLayoutChanged` prop.
     */
    onLayoutChanged: h
  };
}
function Tt() {
  return function() {
  };
}
function Vt() {
  return ee(null);
}
function Ut() {
  return k(null);
}
function ye() {
  const e = rt(Ze);
  return b(
    e,
    "Group Context not found; did you render a Panel or Separator outside of a Group?"
  ), e;
}
function Ot(e, t) {
  const { id: n } = ye(), o = k({
    collapse: ce,
    expand: ce,
    getSize: () => ({
      asPercentage: 0,
      inPixels: 0
    }),
    isCollapsed: () => !1,
    resize: ce
  });
  Ae(t, () => o.current, []), j(() => {
    Object.assign(
      o.current,
      je({ groupId: n, panelId: e })
    );
  });
}
function At({
  children: e,
  className: t,
  collapsedSize: n = "0%",
  collapsible: o = !1,
  defaultSize: i,
  elementRef: r,
  id: l,
  maxSize: s = "100%",
  minSize: a = "0%",
  onResize: u,
  panelRef: c,
  style: h,
  ...S
}) {
  const m = !!l, f = me(l), d = k(null), p = ge(d, r), [, g] = Ye(), { getPanelStyles: v, id: x, registerPanel: y } = ye(), z = u !== null, C = J(
    (O, V, A) => {
      u?.(O, l, A);
    }
  );
  j(() => {
    const O = d.current;
    if (O !== null)
      return y({
        element: O,
        id: f,
        idIsStable: m,
        mutableValues: {
          expandToSize: void 0,
          prevSize: void 0
        },
        onResize: z ? C : void 0,
        panelConstraints: {
          collapsedSize: n,
          collapsible: o,
          defaultSize: i,
          maxSize: s,
          minSize: a
        },
        scheduleUpdate: g
      });
  }, [
    n,
    o,
    i,
    g,
    z,
    f,
    m,
    s,
    a,
    C,
    y
  ]), Ot(f, c);
  const P = v(x, f);
  return /* @__PURE__ */ Q(
    "div",
    {
      ...S,
      "data-panel": !0,
      "data-testid": f,
      id: f,
      ref: p,
      style: {
        ..._t,
        display: "flex",
        flexBasis: 0,
        flexShrink: 1,
        // Prevent Panel content from interfering with panel size
        overflow: "hidden",
        ...P
      },
      children: /* @__PURE__ */ Q(
        "div",
        {
          className: t,
          style: {
            maxHeight: "100%",
            maxWidth: "100%",
            flexGrow: 1,
            ...h
          },
          children: e
        }
      )
    }
  );
}
At.displayName = "Panel";
const _t = {
  minHeight: 0,
  maxHeight: "100%",
  height: "auto",
  minWidth: 0,
  maxWidth: "100%",
  width: "auto",
  border: "none",
  borderWidth: 0,
  padding: 0,
  margin: 0
};
function Wt() {
  return ee(null);
}
function Bt() {
  return k(null);
}
function Nt({
  layout: e,
  panelConstraints: t,
  panelId: n,
  panelIndex: o
}) {
  let i, r;
  const l = e[n], s = t.find(
    (a) => a.panelId === n
  );
  if (s) {
    const a = s.maxSize, u = s.collapsible ? s.collapsedSize : s.minSize, c = [o, o + 1];
    r = H({
      layout: te({
        delta: u - l,
        initialLayout: e,
        panelConstraints: t,
        pivotIndices: c,
        prevLayout: e
      }),
      panelConstraints: t
    })[n], i = H({
      layout: te({
        delta: a - l,
        initialLayout: e,
        panelConstraints: t,
        pivotIndices: c,
        prevLayout: e
      }),
      panelConstraints: t
    })[n];
  }
  return {
    valueControls: n,
    valueMax: i,
    valueMin: r,
    valueNow: l
  };
}
function Ft({
  children: e,
  className: t,
  elementRef: n,
  id: o,
  style: i,
  ...r
}) {
  const l = me(o), [s, a] = ee({}), [u, c] = ee("inactive"), h = k(null), S = ge(h, n), {
    id: m,
    orientation: f,
    registerSeparator: d
  } = ye(), p = f === "horizontal" ? "vertical" : "horizontal";
  return j(() => {
    const g = h.current;
    if (g !== null) {
      const v = {
        element: g,
        id: l
      }, x = d(v), y = F.addListener(
        "interactionStateChange",
        (C) => {
          c(
            C.state !== "inactive" && C.hitRegions.some(
              (P) => P.separator === v
            ) ? C.state : "inactive"
          );
        }
      ), z = F.addListener(
        "mountedGroupsChange",
        (C) => {
          C.forEach(
            ({ derivedPanelConstraints: P, layout: O, separatorToPanels: V }, A) => {
              if (A.id === m) {
                const w = V.get(v);
                if (w) {
                  const L = w[0], E = A.panels.indexOf(L);
                  a(
                    Nt({
                      layout: O,
                      panelConstraints: P,
                      panelId: L.id,
                      panelIndex: E
                    })
                  );
                }
              }
            }
          );
        }
      );
      return () => {
        y(), z(), x();
      };
    }
  }, [m, l, d]), /* @__PURE__ */ Q(
    "div",
    {
      ...r,
      "aria-controls": s.valueControls,
      "aria-orientation": p,
      "aria-valuemax": s.valueMax,
      "aria-valuemin": s.valueMin,
      "aria-valuenow": s.valueNow,
      children: e,
      className: t,
      "data-separator": u,
      "data-testid": l,
      id: l,
      ref: S,
      role: "separator",
      style: {
        flexBasis: "auto",
        ...i,
        flexGrow: 0,
        flexShrink: 0
      },
      tabIndex: 0
    }
  );
}
Ft.displayName = "Separator";
export {
  Dt as Group,
  At as Panel,
  Ft as Separator,
  ut as isCoarsePointer,
  jt as useDefaultLayout,
  Vt as useGroupCallbackRef,
  Ut as useGroupRef,
  Wt as usePanelCallbackRef,
  Bt as usePanelRef
};
//# sourceMappingURL=react-resizable-panels.js.map
